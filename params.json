{
  "name": "ContextConsole",
  "tagline": "Organize your complex console applications",
  "body": "## Introduction\r\n\r\nIcm.ContextConsole is a framework for building applications in the style of [Netsh][1] tool. This tool exposes a series of top-level commands and organizes the rest of them in a hierarchical structure of contexts. This is also a typical organization for command-line interfaces embedded in hardware devices.\r\n\r\n[1]:http://en.wikipedia.org/wiki/Netsh\r\n\r\nLet's see an example for showing the capabilities of the framework. Imagine this context hierarchy:\r\n\r\n* (root context): commands CMD_R1, CMD_R2\r\n * Context A: commands CMD_A1, CMD_A2\r\n * Context B: commands CMD_B1, CMD_B2\r\n     * Context C: command CMD_C1\r\n\r\nOur application is called APP.EXE. We can do the following things:\r\n\r\nDirectly execute any command:\r\n\r\n    > APP.EXE CMD_R1\r\n    Executing command CMD_R1\r\n    > APP.EXE A CMD_A2\r\n    Executing command CMD_A2\r\n    > APP.EXE B C CMD_C1\r\n    Executing command CMD_C1\r\n\r\nEnter interactive mode and execute commands:\r\n\r\n    > APP.EXE\r\n    Welcome to APP's interactive mode!\r\n    APP> CMD_R1\r\n    Executing command CMD_R1\r\n    APP> B\r\n    Going to context B\r\n    APP B> C CMD_C1\r\n    Executing command CMD_C1\r\n    APP B> C\r\n    Going to context C\r\n    APP B C> CMD_R1\r\n    Executing CMD_R1\r\n    APP B C> ..\r\n    Going back to context B\r\n    APP B> ..\r\n    Going back to root context A\r\n    APP> B C\r\n    Going to context C\r\n    APP B C> quit\r\n    Bye!\r\n    >\r\n\r\nAs you can see, at any moment you are able to execute the commands of the current context, all the ancestors and all the descendants; but you must always qualify the commands of the descendants.\r\n\r\n## The beginning: ApplicationFactory\r\n\r\nThis class fires up the system by initializing with `Initialize`. This method configures the dependency injector with the standard services for the following interfaces:\r\n\r\n- `IContextManager`: This service is used by the root context to instantiate contexts and actions.\r\n- `IInteractor`: This service is used by the actions to interact with the user.\r\n- `ITokenParser`: This service splits lines into tokens (taking into account quotes, quote escaping, etc.).\r\n- `IContextTreeBuilder`: This service builds the hierarchy of context, in the form of a `ITreeNode(Of IContext)`.\r\n- `IContext`: There can be many contexts, and they must be bound to the interface if we use the standard `IContextTreeBuilder`.\r\n\r\nAfter initialization, the root context is instantiated and initialized.\r\n\r\nFinally, it enters a loop in which the root context is asked to execute commands until one of them returns `false` upon execution.\r\n\r\nWhat does an application do to execute commands?\r\n\r\nThe `StandardApplication` class provides a simple implementation that:\r\n\r\n- Uses the interactor to ask a command line\r\n- Uses the token parser to split the command line\r\n- Gets the execution context by interpreting tokens as controller names (that must be each children of the former) until one token fails to be interpreted as such or we run out of tokens.\r\n- If run out of tokens, change to the final context\r\n- In other case, the next token must be an action name and the rest of tokens are enqueued for further use within the selected action\r\n- Uses action finder to get the action instance.\r\n- Executes the action (`IAction.Execute`)\r\n- If the action is a \"quit\" action then returns true\r\n- If the mode is not fully interactive (something has come from the environment command line) then returns true\r\n- Else, returns false\r\n\r\nNotable facts: nowhere it is used the `Console` class directly. An appropriate `IFrontInteractor` could be used to get or set values from a GUI, for example, or a network connection. In fact, the provided default interactors to not use `Console` either but streams. The `Console` streams are taken only when you use the default constructor.\r\n\r\n## OK, so how do I start\r\n\r\nYou can do something as simple as creating a front controller inheriting from `FrontController`. Add some routines. In your `Main` method, create a `ConsoleMvcApplication` instance and call `Start()`. That's all!\r\n\r\nIf you want to classify all the actions of your ConsoleMvc app into controllers, just create more classes, each of them inheriting from `BackController` and put the actions into them.\r\n\r\nIf you want to customize the services, you can inherit from `ConsoleMvcApplication` and override `Initialize`. Get `Icm.Ninject.Kernel` and bind the services as you please. Just remember that all the aforementioned services must be bound (except for `IBackController`).",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}